(deftype (Lens a b) [
  -get (Fn [&a] &b)
  -set (Fn [&a b] a)
])

; should be f a b and work with higher orders, but oh well
(deftype (Prism a b) [
  -get (Fn [&a] (Maybe b))
  -set (Fn [&a b] a)
])

(defmodule Lens
  (defn get [l el]
    (~(-get l) el))

  (defn set [l el v]
    (~(-set l) el v))

  (defn compose [ab bc]
    (Lens.init
      (fn [a] (get bc (get ab a)))
      (fn [a c]
        (let [inner (set bc (get ab a) c)]
          (set ab a inner)))))

  (defn update [l p f]
    (let [transformed (~f (get l p))]
      (set l p transformed)))

  (defn to-prism [l]
    (Prism.init
      (fn [a] (Maybe.Just @(get l a)))
      @(-set l)))

  (defndynamic for- [t el]
    (list 'Lens.init
      (Symbol.prefix t el)
      (list 'fn ['a 'b]
        (list (Symbol.prefix t (Symbol.join ['set- el])) '(copy a) 'b))))

  (defmacro for [t el]
    (Lens.for- t el))
)

(defmodule Prism
  (defn get [l el]
    (~(-get l) el))

  (defn set [l el v]
    (~(-set l) el v))

  (defn compose [ab bc]
    (Prism.init
      (fn [a]
        (match (get ab a)
          (Maybe.Nothing) (Maybe.Nothing)
          (Maybe.Just b) (get bc &b)))
      (fn [a c]
        (match (get ab a)
          (Maybe.Nothing) @a
          (Maybe.Just b)
            (let [inner (set bc &b c)]
              (set ab a inner))))))

  (defn update [l p f]
    (match (get l p)
      (Maybe.Nothing) @p
      (Maybe.Just a)
        (let [transformed (~f a)]
          (set l p transformed))))
)
